:imagesdir: ./images

[[appendix_d]]
== Appendix D: M-mode TSM based deployment model

This deployment model is intended for systems that prioritize simplicity over a
feature-rich design due to constraints such as limited hardware capabilities, a
reduced trusted computing base, or the need to ease safety and security
verification. Typical examples include high-end embedded or edge systems
operating on less complex hardware than cloud-grade servers, and high-assurance
systems where a simpler architecture facilitates formal verification of
properties like correctness or isolation.


[id=dep3]
[caption="Figure {counter:image}"]
[title= ": M-mode TSM based deployment model for CoVE"]
image::img_11.png[align=center]

=== Overview
<<dep3>> shows that the deployment model supports a single confidential
supervisor domain in which the TSM runs along with the TSM driver in the M-mode.
This single confidential supervisor domain can run multiple TVMs. The TSM
isolates them from each other using the G-stage page tables. TSM isolates the
hosting supervisor domain (i.e., OS/VMM and non-confidential applications and
VMs) from the confidential supervisor domain (TVMs) using a hardware memory
isolation mechanism, like PMP. The supervisor domain access protection (Smmtt)
extension is therefore not required in this model but not precluded. IO accesses
to confidential memory must be prevented, for example, with IOPMP.

[NOTE]
====
Since the TSM is not required to run in the HS-mode, this deployment model
supports systems that emulate the hypervisor extension or run TVMs and OS/VMM in
S-mode. The latter requires use of a hardware memory isolation mechanism that
enforces memory accesses to confidential memory while being only controlled by
the TSM, e.g., PMP.
====

=== Static memory partitioning
The deployment model proposes static partitioning of memory into confidential
and non-confidential to simplify formal reasoning about the correctness of the
TVM execution and isolation. The TSM performs this paritioning early during the
boot of the platform, resulting in the following advantages:

. simplified formal reasoning about the ownership of memory,
. attestation that covers static system configuration (e.g., values of PMP
registers),
. reduced attack surface between OS/VMM and TSM, i.e., narrower ABI and OS/VMM
lacks control over physical page allocation to TVMs.

A possible negative consequence of static partitioning is underutilization of
resources. Specifically, confidential memory created at platform initialization
might be larger than the required amount of memory utilized by TVMs and the TSM
during runtime.
Lack of the conversion mechanism of confidential memory pages to
non-confidential memory (enabled for example by Smmtt) prevents the hosting
supervisor domain (OS/VMM, applications, and VMs) from using the memory
over-provisioned by the confidential supervisor domain (TSM, TVMs).

=== TVM creation
To reduce the complexity of the TSM implementation and its ABI, the TSM creates
a TVM as a result of a single operation triggered with the
`sbi_covh_promote_to_tvm()` call. Specifically, OS/VMM constructs a regular VM
in non-confidential memory and requests the TSM to promote it to a TVM. To
promote a VM to a TVM, the TSM copies VM's data, page tables, and the boot vCPU
state into confidential memory. When the request succeeds, OS/VMM marks the VM
as a TVM, so that it can then properly resume its execution via TSM.

[NOTE]
====
The promotion mechanism enables use cases in which a running VM gets
promoted to a TVM. To support attestation, such promotion should occur when
content of VM's runtime state is predictable, so that it is feasible to
calculate reference integrity measurements. However, there might be also use
cases when promotion would occur after that point or when some VM pages
(e.g., containing custom boot firmware or provisioning code) should not become
part of TVM. In such a case, OS/VMM can adjust the FDT to mark selected pages
as zero-pages and expect the TSM to clear them during promotion.
====

=== Local attestation
Embedded systems might operate without access to a network, which prevents use
of remote attestation. For this reason, this deployment model also supports
local attestation, in which the TSM attests to the integrity of the TVM image
during its creation and allows its execution only when it contains a specfic
`TVM attestation payload` (TAP). This payload carries a cryptographic proof
issued with the expected attestation key specific to the TSM integrity and
platform configuration.
The pointer to TAP is passed in a call to promote a VM to a TVM. If it is zero,
then remote attestation is used, otherwise local attestation is used. The TSM
must verify that the attestation (i.e., integrity measurements, configuration of
the hardware platform) of the TVM match the values specified by the TVM creator
in the TAP.

Local attestation utilizes one or more of the following properties:

. The TSM must be able to verify that a TVM creator authorized the TVM to run
on the platform.
. The TSM enforces that only TVMs created by a trusted partner runs on the
hardware.

Separate mechanisms may be used to achieve these goals.

==== Linking TVM to the platform
A CoVE-enabled platform must consist of a mechanism to identify the platform,
for example via cryptographic keys exposed by an implementation-specific
mechanism, such as hardware root of trust. The creator of the VM must then be
able to link the identity key with the hardware and use it to encode the TAP.
Only the TSM running on that platform must have access to the key that permits
it to decode the TAP. Access to such key should be linked to the integrity of
the TCB, i.e., the TSM and other M-mode firmware.
After successful local attestation, the TVM should be able to request the TSM to
retrieve secrets encoded in the TAP using an ABI call
(`sbi_covg_retrieve_secret()`).

[NOTE]
====
One common pattern is to protect the TVM image confidentiality at rest by
encrypting the VM disk with a key that the TVM receives during boot after
attestation.
====

==== TVM Authorization
A CoVE-enabled platform might restrict what TVM are allowed to run. There should
be then an implementation-specific mechanism to provide the TSM with a list of
public keys of those authorized to sign TVM images for execution on the
platform. The TVM owner will then sign TAP associated with the TVM with his
corresponding private key. When the VM is being promoted to a TVM, the
TSM checks the signature inside the TAP to decide if this TVM is authorized to
execute. If the signature is not valid, the TSM rejects to promote the VM.

=== Further recommendations
Embedded systems with real-time requirements must have a fixed upper bounded
execution time. This requires determining the maximal number of instructions
that can execute between TVM context switches. From this reason, this deployment
model recommends an uninterruptible TSM. <<depd2>> shows this operation mode, in
which TSM running in M-mode exposes COVH and COVG ABI to OS/VMM and TVM,
respectively. During TVM execution, all exceptions and interrupts trap directly
to the TSM due to `medeleg` and `mideleg` configurations.

[id=depd2]
[caption="Figure {counter:image}"]
[title= ": TSM operation"]
image::img_12.png[align=center]
